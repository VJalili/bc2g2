using INode = BC2G.Graph.Model.INode;

namespace BC2G.Graph.Db.Neo4j.BitcoinMappers;

public abstract class BitcoinEdgeMapper : IEdgeMapper
{
    public const string csvDelimiter = BitcoinBlockGraphMapper.csvDelimiter;
    public const string labelsDelimiter = BitcoinBlockGraphMapper.labelsDelimiter;

    public static string CreatesEdgeQuery
    {
        get { return $"MERGE (block)-[:Creates {{{Props.Height.GetLoadExp(":")}}}]->(target) "; }
    }
    public static string RedeemsEdgeQuery
    {
        get { return $"MERGE (source)-[:Redeems {{{Props.Height.GetLoadExp(":")}}}]->(block) "; }
    }

    public static string GetNodeQuery(
        string variable, string labels, 
        Property idProp, 
        Property typeProp)
    {
        // An example of the populated template.
        //
        // MERGE (source:Script
        // {Address:line.SourceAddress})
        // ON CREATE SET source.ScriptType=line.SourceType
        // ON MATCH SET source.ScriptType =
        // CASE line.SourceType
        // WHEN 'Unknown' THEN source.ScriptType
        // ELSE line.SourceType
        // END
        //

        return
            $"MERGE ({variable}:{labels} " +
            $"{{{idProp.GetLoadExp(":")}}}) " +
            $"ON CREATE SET {variable}.{typeProp.GetLoadExp("=")} " +
            $"ON MATCH SET {variable}.{typeProp.Name} = " +
            $"CASE {Property.lineVarName}.{typeProp.CsvHeader} " +
            $"WHEN '{nameof(ScriptType.Unknown)}' THEN {variable}.{typeProp.Name} " +
            $"ELSE {Property.lineVarName}.{typeProp.CsvHeader} " +
            $"END";
    }

    public static string GetNodeQuery(
        string variable, string labels,
        Property idProp)
    {
        return
            $"MERGE ({variable}:{labels} " +
            $"{{{idProp.GetLoadExp(":")}}})";
    }

    public static string GetNodeQuery(
        string variable, string labels, Property idProp, List<Property> props)
    {
        // An example of the query generated by this method 
        // is as the following.
        //
        // MERGE (source:Tx {Txid:line.SourceId})
        // SET
        //     source.Version = COALESCE(line.SourceVersion, source.Version),
        //     source.Size = COALESCE(line.SourceSize, source.Size),
        //     source.VSize = COALESCE(line.SourceVSize, source.VSize),
        //     source.Weight = COALESCE(line.SourceWeight, source.Weight),
        //     source.LockTime = COALESCE(line.SourceLockTime, source.LockTime) 
        //

        var builder = new StringBuilder();
        builder.Append($"MERGE ({variable}:{labels} " +
            $"{{{idProp.GetLoadExp(":")}}}) SET ");

        builder.Append(string.Join(", ", from x in props select x.GetLoad(variable)));

        return builder.ToString();
    }

    public static string GetEdgeQuery(
        List<Property> props, 
        string sourceVar="source", 
        string targetVar="target")
    {
        // An example of the populated template
        // (indentation added for better readibility).
        //
        // CALL apoc.merge.relationship(
        //     source,
        //     line.EdgeType,
        //     {
        //         Value:toFloat(line.Value),
        //         Height:toInteger(line.Height)
        //     },
        //     { Count : 0},
        //     target,
        //     {}
        // )
        // YIELD rel SET rel.Count = rel.Count + 1
        // 

        var builder = new StringBuilder(
            "CALL apoc.merge.relationship(" +
            $"{sourceVar}, " +
            $"{Property.lineVarName}.{Props.EdgeType.CsvHeader}, " +
            $"{{");

        builder.Append(string.Join(", ", from x in props select x.GetLoadExp(":")));

        builder.Append(
            $"}}, " +
            $"{{ Count : 0}}, " + // on create
            $"{targetVar}, " +
            $"{{}}" +             // on update
            $") " +
            $"YIELD rel " +
            $"SET rel.Count = rel.Count + 1");

        return builder.ToString();
    }

    public static string GetBlockQuery(string varName)
    {
        return
            $"MERGE ({varName}:{BlockMapper.label} {{" +
            $"{Props.Height.GetLoadExp(":")}" +
            "}) ";
    }

    public abstract string GetCsvHeader();
    public abstract string GetCsv(IEdge<INode, INode> edge);
    public abstract string GetQuery(string filename);

    public virtual void ToCsv(
        IEnumerable<IEdge<INode, INode>> edges, 
        string filename)
    {
        using var writer = new StreamWriter(filename, append: true);
        if (new FileInfo(filename).Length == 0)
            writer.WriteLine(GetCsvHeader());

        foreach (var edge in edges)
            writer.WriteLine(GetCsv(edge));
    }
}
