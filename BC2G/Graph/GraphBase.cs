using BC2G.Model;
using System.Collections.Concurrent;
using System.Collections.ObjectModel;

namespace BC2G.Graph
{
    /// <summary>
    /// This class can be used to convert all the 
    /// sources (vin) and tagets (vout) of all transactions
    /// in a block to a graph. 
    /// 
    /// In order to use it: on each transaction (tx), use 
    /// the `AddSource` and `AddTarget` methods to add 
    /// sources (vin) and targets (vout), respectively.
    /// Then, **before moving to the next transaction**, 
    /// call the `UpdateGraph` method. If transaction is 
    /// not `coinbase`, you'll need to pass a list of 
    /// all the miner addresses to which the reward 
    /// is paid. This list will be used to collect 
    /// fees. 
    /// </summary>
    public class GraphBase : IEquatable<GraphBase>
    {
        public const string CoinbaseTxLabel = "Coinbase";
        public const string AutoGeneratedPrefix = "AutoGenerated_";

        public ReadOnlyCollection<Edge> Edges
        {
            get
            {
                return new ReadOnlyCollection<Edge>(_edges.Values.ToList());
            }
        }
        public ReadOnlyCollection<string> Nodes
        {
            get
            {
                return new ReadOnlyCollection<string>(_nodes.Keys.ToList());
            }
        }

        private readonly ConcurrentDictionary<int, Edge> _edges = new();
        private readonly ConcurrentDictionary<string, byte> _nodes = new();

        protected readonly ConcurrentDictionary<string, double> _sources = new();
        protected readonly ConcurrentDictionary<string, double> _targets = new();
        private double _totalInputValue;
        private double _totalOutputValue;

        public void UpdateGraph(List<string>? rewardAddresses = null)
        {
            if (_sources.IsEmpty)
                BuildGenerativeTxGraph();
            else
            {
                if (rewardAddresses == null)
                    throw new ArgumentNullException(
                        nameof(rewardAddresses), 
                        $"{nameof(rewardAddresses)} cannot be null");
                else
                    BuildTxGraph(rewardAddresses);
            }

            _sources.Clear();
            _targets.Clear();
        }

        public void AddEdge(Edge edge)
        {
            /// Note that the hashkey is invariant to the edge value.
            /// If this is changed, the `Equals` method needs to be
            /// updated accordingly.
            _edges.AddOrUpdate(
                edge.GetHashCode(true), edge,
                (key, oldValue) => new Edge(
                    edge.Source,
                    edge.Target,
                    edge.Value + oldValue.Value,
                    edge.Type));

            _nodes.TryAdd(edge.Source, 0);
            _nodes.TryAdd(edge.Target, 0);
        }

        public void AddEdges(ICollection<Edge> edges)
        {
            foreach (var edge in edges)
                AddEdge(edge);
        }

        public void AddSource(string source, double value)
        {
            if (string.IsNullOrEmpty(source))
            {
                /// There is a very rare chance for the outer while 
                /// to run more than once. It runs for a second time 
                /// if in the timespan between when it has determined a
                /// random key that does not exist in the dictionary 
                /// and by the time it tries to add it, a very same 
                /// random key is already added.
                do
                {
                    do source = AutoGeneratedPrefix + Utilities.GetRandomString(16);
                    while (_sources.ContainsKey(source));
                }
                while (_sources.TryAdd(source, Utilities.Round(value)));
            }
            else
            {
                _sources.AddOrUpdate(
                    source, Utilities.Round(value),
                    (_, oldValue) => Utilities.Round(oldValue + value));
            }

            _totalInputValue = Utilities.Round(_totalInputValue + value);
        }

        public void AddTarget(string target, double value)
        {
            _targets.AddOrUpdate(
                target,
                Utilities.Round(value),
                (_, oldValue) => Utilities.Round(oldValue + value));

            _totalOutputValue = Utilities.Round(_totalOutputValue + value);
        }

        private void BuildGenerativeTxGraph()
        {
            foreach (var item in _targets)
                AddEdge(new Edge(
                    CoinbaseTxLabel,
                    item.Key,
                    item.Value,
                    EdgeType.Generation));
        }

        private void BuildTxGraph(List<string> rewardAddresses)
        {
            var changes = _targets.Where(x => _sources.ContainsKey(x.Key)).ToList();
            switch (changes.Count)
            {
                case 0: break; // no change, all the input is sent to the output.
                case 1:
                    /// Adding a new key is not expected to happen.
                    /// AddOrUpdate is used because that is currently 
                    /// the only thread-safe approach to update the value
                    /// to a function of old and new value, without
                    /// implementing custom code.
                    _sources.AddOrUpdate(
                        changes[0].Key,
                        _sources[changes[0].Key],
                        (_, oldValue) => Utilities.Round(oldValue - changes[0].Value));

                    _targets.TryRemove(changes[0]);
                    _totalInputValue = Utilities.Round(_totalInputValue - changes[0].Value);
                    break;
                default:
                    // This is not expected to happen.
                    throw new NotImplementedException();
            }

            double fee = Utilities.Round(_totalInputValue - _totalOutputValue);
            if (fee > 0.0)
                foreach (var s in _sources)
                    _sources.AddOrUpdate(
                        s.Key, _sources[s.Key],
                        (_, oldValue) => Utilities.Round(oldValue - fee));

            /// The AddOrUpdate method is only expected to update, 
            /// adding a new key is not expected to happen. See
            /// the above comment.


            foreach (var s in _sources.Where(x => !x.Key.StartsWith(AutoGeneratedPrefix)))
            {
                foreach (var t in _targets)
                    AddEdge(new Edge(
                        s.Key, t.Key,
                        Utilities.Round(t.Value * Utilities.Round(
                            s.Value / Utilities.Round(
                                _totalInputValue - fee))),
                        EdgeType.Transfer));

                foreach (var m in rewardAddresses)
                    AddEdge(new Edge(
                        s.Key, m,
                        Utilities.Round(fee / rewardAddresses.Count),
                        EdgeType.Fee));
            }
        }

        public bool Equals(GraphBase? other)
        {
            if (other == null)
                return false;

            if (ReferenceEquals(this, other))
                return true;

            var otherNodes = other.Nodes;
            if (_nodes.Count != otherNodes.Count)
                return false;

            var otherEdges = other.Edges;
            if (_edges.Count != otherEdges.Count)
                return false;

            var equal = Enumerable.SequenceEqual(
                Nodes.OrderBy(x => x),
                otherNodes.OrderBy(x => x));

            if (!equal)
                return false;

            var hashes = new HashSet<int>(_edges.Keys);
            foreach (var edge in otherEdges)
                /// Note that this hash method does not include
                /// edge value in the computation of hash key;
                /// this is in accordance with home with _edges.Keys
                /// are generated in the AddEdge method.
                if (!hashes.Remove(edge.GetHashCode(true)))
                    return false;

            if (hashes.Count > 0)
                return false;

            return true;
        }

        public override bool Equals(object? obj)
        {
            return Equals(obj as GraphBase);
        }

        public override int GetHashCode()
        {
            throw new NotImplementedException();
        }
    }
}
