using bitcoin_data.Model;
using Moq;
using Moq.Protected;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Security.Cryptography;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace BitcoinData.Tests
{
    public class BaseTests : IDisposable
    {
        // The IDisposable interface is implemented following
        // .NET docs: https://docs.microsoft.com/en-us/dotnet/api/system.idisposable?view=net-6.0

        public HttpClient Client { get; }
        public string TempExeDir { get; }

        public string ChainInfoFilename { set; get; } = "chaininfo.json";
        public string ChecksumsFilename { set; get; } = "checksums.json";
        public string ResourcesDir { set; get; } = "Resources";
        public string ExpOutputDir { set; get; } = "Expected";
        public string ApiMockData { set; get; } = "APIMock";

        private bool disposed = false;

        public BaseTests(List<int> testBlocks)
        {
            do { TempExeDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString()); }
            while (Directory.Exists(TempExeDir));
            Directory.CreateDirectory(TempExeDir);

            var paramseters = new List<MessageHandlerMockingParams>
            {
                new MessageHandlerMockingParams(
                    "chaininfo.json",
                    File.ReadAllText(Path.Combine(
                        ResourcesDir, ApiMockData, ChainInfoFilename)))
            };

            foreach (var height in testBlocks)
                paramseters.AddRange(GetBlockMockingParams(height));

            /// For every endpoint that BitcoinAgent access on bitcoin-qt, 
            /// this mocking approach creates the endpoint and populates it 
            /// with predefined data (i.e., Resources/APIMock/**). For instance,
            /// BitcoinAgent will GET the `/rest/chaininfo.json` endpoint to
            /// determine if the client is on the `main` chain or not. For
            /// this to work, this mocking approach loads a predefined 
            /// response (stored as `/Resources/APIMock/chaininfo.json`)
            /// and sets as the `/rest/chaininfor.json` response. Hence,
            /// enabliing the simulating API calls to bitcoin-qt.
            /// All the data under the `Resources` directory are
            /// generated by `TestDataGenerator`.
            var mock = GetMockMessageHandler(paramseters);

            Client = new HttpClient(mock.Object);
        }

        public string GetExpOutputDir(int fromHeight, int toHeight)
        {
            return Path.Combine(ResourcesDir, ExpOutputDir, $"{fromHeight}-{toHeight}");
        }

        private Mock<HttpMessageHandler> GetMockMessageHandler(
            Mock<HttpMessageHandler> mock, MessageHandlerMockingParams param)
        {
            /// This approach of mocking HttpClient is partially based 
            /// on the following StackOverflow topic:
            /// https://stackoverflow.com/a/44028625/947889

            /// Note that it is essential to create a new instance
            /// of HttpResponseMessage at the ReturnsAsync func body.
            /// Accordingly, everytime a call is made to an endpoint, 
            /// a new response is returned to the caller. Otherwise
            /// (reusing an existing HttpResponseMessage, e.g., by 
            /// creating it outside the func), will return the same 
            /// response to the second caller on a given endpoint. 
            /// The second caller will start reading the response 
            /// from the point the first caller had left; if left 
            /// at the end, then the second caller will read an 
            /// empty string.

            mock.Protected().Setup<Task<HttpResponseMessage>>(
                "SendAsync",
                ItExpr.Is<HttpRequestMessage>(
                    x => x.RequestUri.AbsolutePath.Contains(param.Endpoint)),
                ItExpr.IsAny<CancellationToken>())
                .ReturnsAsync(() =>
                     new HttpResponseMessage()
                     {
                         Content = param.Response
                     });

            return mock;
        }

        private Mock<HttpMessageHandler> GetMockMessageHandler(
            List<MessageHandlerMockingParams> parameters)
        {
            var mock = new Mock<HttpMessageHandler>();
            foreach (var param in parameters)
                mock = GetMockMessageHandler(mock, param);
            return mock;
        }

        private string GetBlockJson(int blockHeight)
        {
            return Path.Combine(
                ResourcesDir, ApiMockData,
                blockHeight.ToString(),
                $"bl_{blockHeight}.json");
        }
        private string GetTxJson(int blockHeight, string txId)
        {
            return Path.Combine(
                ResourcesDir, ApiMockData,
                blockHeight.ToString(),
                $"tx_{txId[..8]}.json");
        }

        private List<MessageHandlerMockingParams> GetBlockMockingParams(int blockHeight)
        {
            var prms = new List<MessageHandlerMockingParams>();

            Block? block;
            string filename = GetBlockJson(blockHeight);
            using (var stream = new StreamReader(filename))
                block = JsonSerializer.Deserialize<Block>(stream.BaseStream);
            block = block ?? throw new Exception($"Invalid JSON file {filename}");

            prms.Add(new MessageHandlerMockingParams(
                $"blockhashbyheight/{blockHeight}.hex", block.Hash));

            prms.Add(new MessageHandlerMockingParams(
                $"block/{block.Hash}.json", File.ReadAllText(filename)));

            foreach (var tx in block.Transactions)
                foreach (var input in tx.Inputs.Where(x => x.TxId != null))
                {
                    prms.Add(new MessageHandlerMockingParams(
                        $"tx/{input.TxId}.json",
                        File.ReadAllText(GetTxJson(
                            block.Height, input.TxId))));
                }

            return prms;
        }

        public Dictionary<string, string> GetChecksums(string path)
        {
            string filename = Path.Combine(path, ChecksumsFilename);

            var checksums = new Dictionary<string, string>();
            using (var stream = File.OpenRead(filename))
                checksums = JsonSerializer.Deserialize<Dictionary<string, string>>(stream);

            return checksums ??
                throw new Exception(
                    "Error reading checksums file.");
        }

        public static string Getchecksum(string filename)
        {
            using var md5 = MD5.Create();
            using var stream = File.OpenRead(filename);
            return BitConverter.ToString(
                md5.ComputeHash(stream))
                .Replace("-", string.Empty)
                .ToLower();
        }


        // The IDisposable interface is implemented following .NET docs:
        // https://docs.microsoft.com/en-us/dotnet/api/system.idisposable?view=net-6.0
        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    Directory.Delete(TempExeDir, true);
                }

                disposed = true;
            }
        }
    }
}